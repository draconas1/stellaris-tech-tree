<!doctype html>
<html>
<head>
    <title>Tech Tree</title>

    <script type="text/javascript" src="graph.json"></script>
    <script type="text/javascript" src="dist/vis.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
    <link href="dist/vis-network.min.css" rel="stylesheet" type="text/css"/>

    <style type="text/css">
        #mynetwork {
            width: 100%;
            height: 80vh;
            border: 1px solid lightgray;
        }
        .topBar {
            display: flex;
            align-items: center;
            justify-content: space-evenly;
        }
		
		.title {
			font-family: 'Orbitron', sans-serif;
		}
    </style>
</head>
<body>
<h1 class="title">Stellaris Tech Tree</h1>
<div class="topBar">
    <h1>Filter</h1>
	<label for="filterBox">Filter tree to:</label>
	<select id="filterBox" onchange="redraw()">
		<option value="All">All</option>
		<option value="Physics">Physics</option>
		<option value="Society">Society</option>
		<option value="Engineering">Engineering</option>
	</select>
	<label for="showImages">Use images instead of labels:</label>
	<input type="checkbox" id="showImages" onclick="redraw()">
    <h1>Search</h1>
    <form onsubmit="return findNodesByText()">
        <label for="searchBox">Find tech by name:</label>
        <input id="searchBox" type="text"/>
        <button type="submit">summit</button>
    </form>
</div>

<div id="mynetwork"></div>

To contact me, is best on discord <a href="https://discordapp.com/invite/CMjnnET">The Stellaris Modding Den</a> drop a msg to Draconas. 

<script type="text/javascript">

    var network;
    var allNodes;
    var allEdges;
    var highlightActive = false;
    // create an array with nodes
    //import * as vis from "dist/vis";
    var rawData = GraphData;
    var allImages = {};
	var allImages2 = {};

    var nodesDataset;
    var edgesDataset = new vis.DataSet(rawData.edges);


    function redraw() {
        var techAreaFilter = document.getElementById("filterBox").value;
        if (techAreaFilter == undefined || techAreaFilter == '' || techAreaFilter == 'All') {
            nodesDataset = new vis.DataSet(rawData.nodes);
        } else {
            let newNodes = [];
            for (const node of rawData.nodes) {
                // var node = rawData.nodes[nodeId];
                if (node.group === techAreaFilter) {
                    newNodes.push(node);
                }
            }
            nodesDataset = new vis.DataSet(newNodes);
        }


        // create a network
        var container = document.getElementById('mynetwork');
        var data = {
            nodes: nodesDataset,
            edges: edgesDataset
        };
        var options = {
            nodes: {
                shape: 'box',
                font: {
                    size: 26
                },
                color: {
                    highlight: {
                        background: 'red'
                    }
                },
                borderWidth: 0,
                borderWidthSelected: 2,
                shapeProperties: {
                    useBorderWithImage: true,
					borderRadius: 6
                }
            },
            edges: {
                smooth: {
                    type: 'cubicBezier',
                    forceDirection: 'horizontal',
                    roundness: 0.4
                },
                dashes: true
            },
            layout: {
                hierarchical: {
                    direction: "LR",
                    sortMethod: 'directed',
                    levelSeparation: 600,
                    nodeSpacing: 120,
                    treeSpacing: 100,
                    blockShifting: true,
                    edgeMinimization: true,
                    parentCentralization: true
                }
            },
            groups: {
                Physics: {
                    color: {
                        background: '#427df4'
                    }
                },
                Society: {
                    color: {
                        background: '#80d17d'
                    }
                },
                Engineering: {
                    color: {
                        background: '#e5a649'
                    }
                }
            },
            interaction: {
                dragNodes: true,
                navigationButtons: true,
                keyboard: true
            },
            physics: {
                enabled: false
            }

        };
		
		var checkBox = document.getElementById("showImages");
		 if (checkBox.checked == true){
			options.nodes.shape = 'image';
			options.nodes.borderWidth = 2;
			options.groups.Physics.color.border =  '#427df4';
			options.groups.Society.color.border =  '#80d17d';
			options.groups.Engineering.color.border =  '#e5a649';
		 } 
		
		
		
        network = new vis.Network(container, data, options);

        // get a JSON object
        allNodes = nodesDataset.get({returnType: "Object"});
        allEdges = edgesDataset.get({returnType: "Object"});

         
		 network.on("click", neighbourhoodHighlight); 
		 
		 
		 if (checkBox.checked == false){
			for (let nodeId in allNodes) {
				let node = allNodes[nodeId];
				if (node.hasImage) {
					allImages[nodeId] = new Promise((resolve, reject) => {
						let img = new Image()
						img.src = node.image
						img.onload = resolve.bind(this, img)
						img.onerror = img.onabort = reject
					});
					
					let img = new Image()
					img.src = node.image
					allImages2[nodeId] = img;
				}
			}

		   

		
			network.on("afterDrawing", function (ctx) {
				for (const nodeId in allNodes) {
					let node = allNodes[nodeId];
					if (node.hasImage) {                  
						// allImages[nodeId].then((img) => {
						// 	let boundingbox = network.getBoundingBox([nodeId]);
						//	ctx.drawImage(img, boundingbox.right, boundingbox.top - ((img.height - (boundingbox.bottom - boundingbox.top)) / 2));
						// });                    
						
						let boundingbox = network.getBoundingBox([nodeId]);
						let img = allImages2[nodeId];
						ctx.drawImage(img, boundingbox.right, boundingbox.top - ((img.height - (boundingbox.bottom - boundingbox.top)) / 2));
					}
				}
			});
		}

        return false;
    }

    function findNodesByText() {
        var toFind = document.getElementById("searchBox").value;
        toFind = toFind.toUpperCase();
        var found = [];
        for (var nodeId in allNodes) {
            var node = allNodes[nodeId];
            if (node.label.toUpperCase().indexOf(toFind) > -1) {
                found.push(nodeId);
            }
        }
        if (found.length > 0) {
            network.selectNodes(found);
            network.fit({
                nodes: found
            });
        }
        return false;
    }

    // Always give a direction else it will stack overflow due to infinite loop.
    // due to not checking if its already visited.
    // fortunately a tech tree cannot contain loops
    function findAllConnections(node, direction) {
        var connectedNodes = network.getConnectedNodes(node, direction);
        if (connectedNodes.length > 0) {
            var i;
            var allConnectedNodes = [].concat(connectedNodes);
            for (i = 0; i < connectedNodes.length; i++) {
                var connectedNode = connectedNodes[i];
                var connections = findAllConnections(connectedNode, direction);
                allConnectedNodes = allConnectedNodes.concat(connections);
            }

            return allConnectedNodes;
        }
        return [];
    }

    // does the edge connect to one of the fake root nodes
    function connectsToRoot(edge) {
        return edge.from == 'Engineering-root' || edge.from == 'Society-root' || edge.from == 'Physics-root';
    }

    function highlightEdge(edge) {
        if (connectsToRoot(edge)) {
        } else {
            var color = {};
            color.color = '#000000';
            color.highlight = '#000000';
            edge.color = color;
            edge.width = 3;
            edge.dashes = false;
        }

    }

    function highlightEdges(nodePathIds) {
        for (i = 0; i < nodePathIds.length; i++) {
            // can only get all the edges connected to our node, which includes edges to irrelvant nodes
            var edges = network.getConnectedEdges(nodePathIds[i]);
            for (j = 0; j < edges.length; j++) {
                var edge = allEdges[edges[j]];
                // only highlight our edge if its from and to ends are on our path
                if (nodePathIds.indexOf(edge.from) > -1 && nodePathIds.indexOf(edge.to) > -1) {
                    highlightEdge(edge);
                }
            }
        }
    }

    function neighbourhoodHighlight(params) {
        //reset first
        for (var edgeId in allEdges) {
            var edge = allEdges[edgeId];
            if (connectsToRoot(edge)) {
            } else {
                var color = {};
                color.color = 'grey';
                edge.color = color;
                edge.width = 1;
                edge.dashes = true;
            }
        }

        // if something is selected:
        if (params.nodes.length > 0) {
            highlightActive = true;
            var i, j;
            var selectedNode = params.nodes[0];

            // find and highlight the path
            var fromNodes = findAllConnections(selectedNode, 'from').concat(selectedNode);
            var toNodes = findAllConnections(selectedNode, 'to').concat(selectedNode);
            highlightEdges(fromNodes);
            highlightEdges(toNodes);


        } else if (highlightActive == true) {
            highlightActive = false
        }

        // transform the object into an array
        var updateArray = [];
        for (edgeId in allEdges) {
            if (allEdges.hasOwnProperty(edgeId)) {
                updateArray.push(allEdges[edgeId]);
            }
        }
        edgesDataset.update(updateArray);
    }

    redraw();
</script>


</body>
</html>
