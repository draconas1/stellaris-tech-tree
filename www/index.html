<!doctype html>
<html>
<head>
    <title>Tech Tree</title>

    <script type="text/javascript" src="graph.js"></script>
    <script type="text/javascript" src="graphOptions.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>
    <script type="text/javascript" src="dist/vis.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
    <link href="dist/vis-network.min.css" rel="stylesheet" type="text/css"/>

    <style type="text/css">
        #mynetwork {
            width: 100%;
            height: 80vh;
            border: 1px solid lightgray;
        }

        .topBar {
            display: flex;
            align-items: center;
            justify-content: space-evenly;
        }

        .title {
            font-family: 'Orbitron', sans-serif;
        }
    </style>
</head>
<body>
<h1 class="title">Stellaris Tech Tree</h1>
<div class="topBar">
    <h1>Filter</h1>
    <label for="filterBox">Filter tree to:</label>
    <select id="filterBox" onchange="redraw()">
        <option value="All">All</option>
        <option value="Physics">Physics</option>
        <option value="Society">Society</option>
        <option value="Engineering">Engineering</option>
    </select>
    <label for="showImages">Use images instead of labels:</label>
    <input type="checkbox" id="showImages" onclick="redraw()">
    <h1>Search</h1>
    <form>
        <label for="searchBox">Find tech by name:</label>
        <input id="searchBox" type="text"/>
    </form>
</div>

<div id="mynetwork"></div>

To contact me, is best on discord <a href="https://discordapp.com/invite/CMjnnET">The Stellaris Modding Den</a> drop a
msg to Draconas.

<script type="text/javascript">

    var network;
    var allNodes;
    var allEdges;
    var rawData = GraphData;

    var nodesDataset;
    var edgesDataset = new vis.DataSet(rawData.edges);

    var onInputhandler = _.debounce(function(event) {
        let toFind = this.value;
        if (toFind.length > 3) {
            toFind = toFind.toUpperCase();
            let found = [];

            Object.values(allNodes).forEach(node => {
                if (node.label.toUpperCase().indexOf(toFind) > -1) {
                    found.push(node.id);
                }
            });

            if (found.length > 0) {
                network.selectNodes(found);
                network.fit({
                    nodes: found,
                    animation: true
                });

                neighbourhoodHighlight({
                    nodes : found
                });
            }
        }
        return false;
    });
    document.getElementById("searchBox").addEventListener("input", onInputhandler);

    async function redraw() {
        var techAreaFilter = document.getElementById("filterBox").value;
        if (techAreaFilter === undefined || techAreaFilter === '' || techAreaFilter === 'All') {
            nodesDataset = new vis.DataSet(rawData.nodes);
        } else {
            //lodash filter with a shorthand for propertyname matches value.
            let newNodes = _.filter(rawData.nodes, ['group', techAreaFilter])
            nodesDataset = new vis.DataSet(newNodes);
        }


        // create a network
        var container = document.getElementById('mynetwork');
        var data = {
            nodes: nodesDataset,
            edges: edgesDataset
        };
        let options = GraphOptions;

        var showImagesCheckbox = document.getElementById("showImages");
        if (showImagesCheckbox.checked === true) {
            options.nodes.shape = 'image';
            options.nodes.borderWidth = 2;
            options.groups.Physics.color.border = '#427df4';
            options.groups.Society.color.border = '#80d17d';
            options.groups.Engineering.color.border = '#e5a649';
        }


        network = new vis.Network(container, data, options);

        // get a JSON object
        allNodes = nodesDataset.get({returnType: "Object"});
        allEdges = edgesDataset.get({returnType: "Object"});

        network.on("click", neighbourhoodHighlight);


        if (showImagesCheckbox.checked === false) {
            let promises = [];
            Object.entries(allNodes).forEach(([nodeId, node]) => {
                if (node.hasImage) {
                    let promise = new Promise((resolve, reject) => {
                        let img = new Image();
                        img.src = node.image;
                        img.onload = resolve.bind(this, {img, nodeId});
                        img.onerror = img.onabort = e =>  {
                            console.log("Failed load load image " + node.image + " " + e);
                            resolve.bind(this, {img: null, nodeId})
                        }
                    });
                    promises.push(promise)
                }
            });

            let allPromises = Promise.all(promises);
            let promiseResults = await allPromises;
            network.on("afterDrawing", ctx =>  addImagesToTextNodes(ctx, promiseResults));
        }

        return false;
    }

    function addImagesToTextNodes(ctx, allImagePromises) {
        // cannot do anything that is async here since this happens after draw but before scaling.
        // so async results in images being drawn afgter the rest of the view has been scaled.
        let downloadedImagesById = {};
        allImagePromises.forEach(result => downloadedImagesById[result.nodeId] = result.img);

        Object.entries(allNodes).forEach(([nodeId, node]) => {
            let img = downloadedImagesById[nodeId];
            if (node.hasImage && img != null) {
                let boundingbox = network.getBoundingBox([nodeId]);
                ctx.drawImage(img, boundingbox.right, boundingbox.top - ((img.height - (boundingbox.bottom - boundingbox.top)) / 2));
            }
        });
    }

    // Always give a direction else it will stack overflow due to infinite loop.
    // due to not checking if its already visited, so forward and back expansion means it just keeps bouncing.
    // fortunately a tech tree cannot contain loops
    function findAllConnections(node, direction) {
        let connectedNodes = network.getConnectedNodes(node, direction);
        if (connectedNodes.length > 0) {
            let allConnectedNodes = [].concat(connectedNodes);
            connectedNodes.forEach(connectedNode => {
                let connections = findAllConnections(connectedNode, direction);
                allConnectedNodes = allConnectedNodes.concat(connections);
            });

            return allConnectedNodes;
        }
        return [];
    }

    // does the edge connect to one of the fake root nodes
    function connectsToRoot(edge) {
        return edge.from === 'Engineering-root' || edge.from === 'Society-root' || edge.from === 'Physics-root';
    }

    function highlightEdge(edge) {
        if (connectsToRoot(edge)) {
        } else {
            let color = {};
            color.color = '#000000';
            color.highlight = '#000000';
            edge.color = color;
            edge.width = 3;
            edge.dashes = false;
        }

    }

    function highlightEdges(nodePathIds) {
        nodePathIds.forEach(nodeId => {
            // can only get all the edges connected to our node, which includes edges to irrelevant nodes
            // //(e.g. other things that also have a pre-requisite of one of our prerequites)
            let connectedEdgeIds = network.getConnectedEdges(nodeId);
            connectedEdgeIds.forEach(edgeId => {
                let edge = allEdges[edgeId];
                // only highlight our edge if its from and to ends are on our path
                if (nodePathIds.indexOf(edge.from) > -1 && nodePathIds.indexOf(edge.to) > -1) {
                    highlightEdge(edge);
                }
            });
        });
    }

    function neighbourhoodHighlight(params) {
        //reset first
        Object.values(allEdges).forEach(edge => {
            if (!connectsToRoot(edge)) {
                var color = {};
                color.color = 'grey';
                edge.color = color;
                edge.width = 1;
                edge.dashes = true;
            }
        });

        // if something is selected:
        params.nodes.forEach(selectedNode => {
            // find and highlight the path
            let fromNodes = findAllConnections(selectedNode, 'from').concat(selectedNode);
            let toNodes = findAllConnections(selectedNode, 'to').concat(selectedNode);
            highlightEdges(fromNodes);
            highlightEdges(toNodes);
        });

        // transform the object into an array
        edgesDataset.update(Object.values(allEdges));
    }

    redraw();
</script>


</body>
</html>
